# BFS에 대해서.
BFS는 너비 우선 탐색 (Breadth-First Search)의 약자이다. BFS란 다음을 의미한다. 
- 루트 노드 (혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법.
- 시작점으로부터 가까운 점을 먼저 방문하고 멀리 떨어져 있는 점을 나중에 방문하는 숭회 방법이다. 

이는 *두 노드 사이의 최단 경로* 혹은 *임의의 경로를 찾고 싶을 때* 사용하는 방법이다. 

## 특징
- 직관적이지 않다. 
  - BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다. 
- BFS는 **재귀적으로 동작하지 않는다.**
- 그래프 탐색의 경우 **어떤 노드를 방문했었는지 여부를 반드시 검사**해야 한다. 
  - 그렇지 않으면 무한루프에 빠질 위험이 존재한다. 
- BFS는 큐를 사용한다. 
  - 선입선출(FIFO)를 원칙으로 탐색
  - 일반적으로 큐를 사용해서 반복적 형태로 구현하는 것이 가장 잘 동작한다. 

## 과정
깊이가 1인 모든 노드를 방문하고 나서 그 다음에는 깊이가 2인 모든 노드를, 그 다음에는 깊이가 3인 모든 노드를 방문하는 식으로 계속 방문하다가 더 이상 방문할 곳이 없으면 참색을 마친다. 
![bfs](./images/bfs-example.png)

1. a노드(시작 노드)를 방문한다. (방문한 노드 체크)
   - 큐에 방문된 노드를 삽입한다. 
   - 초기 상태의 큐에는 시작 노드만이 저장.
     - 즉, a 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃을 방문한다. 
2. 큐에서 꺼낸 노드와 인접한 노드들을 모두 차례로 방문한다. 
   - 큐에서 꺼낸 노드를 방문한다. 
   - 큐에서 꺼낸 노드와 인접한 노드들을 모두 방문한다. 
     - 인접한 노드가 없다면, 큐의 앞에서 노드를 꺼낸다. 
   - 큐에 방문된 노드를 삽입한다. 

3. 큐가 소진될 때까지 계속한다. 

## 복잡도
- 인접 리스트로 표현된 그래프 : O(N+E)
- 인접 행렬로 표현된 그래프 : O(N^2)

## 예제 문제
### 문제
그래프를 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.
### 입력

첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.

### 출력
첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.
### 예제 입출력
```
4 5 1
1 2
1 3
1 4
2 4
3 4
===============
1 2 3 4
```
```
5 5 3
5 4
5 2
1 2
3 4
3 1
===============
3 1 4 2 5
```
```
1000 1 1000
999 1000
===============
1000 999
```
## 정답

```
#include<stdio.h>

int Graph[1001][1001] = {0, };
int BFSvisit[1001] = {0, };
int queue[1001];

void BFS(int v, int N){
    int front = 0;
    int rear = 0;
    int Pop, i;

    printf("%d ", v);
    queue[0] = v;
    rear++;
    BFSvisit[v]=1;

    while(front<rear){
        Pop = queue[front];
        front++;

        for(i=1; i<N+1; i++){
            if(Graph[Pop][i] == 1 && BFSvisit[i] == 0){
                printf("%d ", i);
                queue[rear] = i;
                rear++;
                BFSvisit[i] = 1;
            }
        }
    }
    return;
}

int main(){
    int N, M, Start;
    int i,x,y;
    scanf("%d %d %d", &N, &M, &Start);

    for(i=0; i<M; i++){
        scanf("%d %d", &x,&y);
        Graph[x][y] = 1;
        Graph[y][x] = 1;
    }

    BFS(Start, N);
}
```

# 출처
https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html